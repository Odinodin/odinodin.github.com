<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <link href="/main.css" rel="stylesheet" type="text/css">
  <link href="/highlight.css" rel="stylesheet" type="text/css">
  <title>Rust on the terminal</title>
</head>

<body>
<div class="page page-blog">
  <header>
  <a href="/"><h1 class="logo-text">ODINODIN</h1></a>
  <div class="menu">
    <a href="/">Posts</a>
    <a href="/about">About</a>
  </div>
</header>
  <main>
    <h1>Rust on the terminal</h1>
    <div class="published-container">
      <h3 class="color-primary">2023-07-12</h3>
      <div>
        <a href="/tags/experiments"><div class="badge">experiments</div></a>
      </div>
    </div>
    <div class="blog-content">
    <p>Do you need to make a command line tool, but tired of messy bash scripts that are impossible to read?
Maybe it's faster to write it with a dynamic language like Python, but what about trying a strongly typed language
like Rust?</p>
<p>A while back I came across  <a href="https://github.com/sts10/rust-command-line-utilities">this list</a> of command line tools written in Rust.</p>
<p>There is a lot of innovation on this front and it's obvious that
<a href="https://www.rust-lang.org/">Rust</a> is a language that many prefer to build these kinds of tools with.</p>
<p>It's fun to learn new things, how hard can it be to learn Rust?</p>
<p><img src="/images/2023-07-rust/rust-crab.png" alt="Rust krabbe"></p>
<h2>What are we making?</h2>
<p>To not bite over too much, we need a rightly scoped project that will not take too long to complete.</p>
<p>I often check the price of power in my Tibber-app to know when it's best to start the dish washer.</p>
<p>When I'm at the computer, I always have the terminal up. It's a lot easier to fire away a terminal command than
lifting up the phone and finding the Tibber app.</p>
<p>The finished product looks like this:</p>
<pre><code>$ energipris --today
  Today (Price now 0.888)

 0.89 ┤                                 ╭────────────╮                        ╭───────╮
 0.87 ┤                            ╭────╯            ╰╮              ╭────────╯       ╰──╮
 0.85 ┤                          ╭─╯                  ╰╮            ╭╯                   ╰─╮
 0.83 ┤                        ╭─╯                     ╰╮           │                      ╰─╮
 0.82 ┤                    ╭───╯                        ╰╮         ╭╯                        ╰───╮
 0.80 ┼─╮                 ╭╯                             │         │                             ╰───╮
 0.78 ┤ ╰─╮             ╭─╯                              ╰╮       ╭╯                                 ╰
 0.76 ┤   ╰────╮      ╭─╯                                 ╰╮      │
 0.74 ┤        ╰──────╯                                    │     ╭╯
 0.72 ┤                                                    ╰╮    │
 0.71 ┤                                                     ╰────╯
       ‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
       00:00                   06:00                   12:00                   18:00               24:00
</code></pre>
<p>That means we have to do the following:</p>
<ul>
<li>Parse arguments to the progam</li>
<li>Read a personal Tibber API Token</li>
<li>Fetch prices from the Tibber API using the token</li>
<li>Draw a graph of the prices</li>
</ul>
<h2>How to get started?</h2>
<p>Everything starts by <a href="https://www.rust-lang.org/learn/get-started">installing the tools</a> you need to compile and run Rust program.</p>
<p>Note that Rust handles memory in a novel way that can take some getting used to.</p>
<p>To start a new project you can generate a template with the following command:</p>
<pre><code>cargo new energipris
</code></pre>
<p>To run this program:</p>
<pre><code>cargo run
</code></pre>
<p>Now we have the foundation in place.</p>
<h2>Dependencies</h2>
<p>Rust is designet with a thin standard library. That is a design philosphy I can like. The code in the core has to live
forever, and thus small size means less likely to need to change.</p>
<p>To achieve our goals, we pull in the following dependencies, or "crates" as they are known as in the Rust universe:</p>
<ul>
<li>tokio
<ul>
<li>a runtime with async support</li>
</ul>
</li>
<li>clap
<ul>
<li>Parser for command line arguments</li>
</ul>
</li>
<li>reqwest
<ul>
<li>HTTP-client to be able to talk to the Tibber API</li>
</ul>
</li>
<li>serde
<ul>
<li>JSON parser</li>
</ul>
</li>
<li>rasciigraph
<ul>
<li>To visualize the prices over time</li>
</ul>
</li>
</ul>
<h2>It starts with main()</h2>
<p>The program starts with a main function.</p>
<pre><code class="language-rust hljs"><span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() { 
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>Hold on a minute, this needs some explaining. Main is annotated with a <code>tokio</code> macro which adds support for
asynchronous calls.<br>
<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Makroer</a> in Rust generate code which expands when the program is compiled.</p>
<p>Alernatively you can write the following to achieve the same as the macro:</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
  tokio::runtime::Builder::<span class="hljs-title function_ invoke__">new_multi_thread</span>()
    .<span class="hljs-title function_ invoke__">enable_all</span>()
    .<span class="hljs-title function_ invoke__">build</span>()
    .<span class="hljs-title function_ invoke__">unwrap</span>()
    .<span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-keyword">async</span> {
      <span class="hljs-comment">// ...</span>
    })
}
</code></pre>
<p>Macros are incredibly powerful tools with a lot of sharp edges. The first I think about is what does this macro really
do? It's nice when it works, but as soon as it doesn't, it's not always easy to know where to start debugging.</p>
<h2>Arguments</h2>
<p>We use the <code>clap</code>-crate to parse arguments from the command line. Here we can annotate a struct with a macro in the
following way:</p>
<pre><code class="language-rust hljs"><span class="hljs-meta">#[derive(Parser)]</span>
<span class="hljs-meta">#[command(name = <span class="hljs-string">"energipriser"</span>)]</span>
<span class="hljs-meta">#[command(author = <span class="hljs-string">"Odin Standal &lt;odin@odinodin.com&gt;"</span>)]</span>
<span class="hljs-meta">#[command(version = <span class="hljs-string">"1.0"</span>)]</span>
<span class="hljs-meta">#[command(about = <span class="hljs-string">"Henter energipriser"</span>, long_about = None)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> {
  <span class="hljs-meta">#[arg(long, help = <span class="hljs-string">"Viser dagens priser"</span>)]</span>
  idag: <span class="hljs-type">bool</span>,
  <span class="hljs-meta">#[arg(long, help = <span class="hljs-string">"Viser morgendagens priser"</span>)]</span>
  imorgen: <span class="hljs-type">bool</span>,
}
</code></pre>
<p>Clap sin <code>Parser</code>-makro lesser på med magi for oss. F.eks så får vi en nyttig beskrivelse via <code>--help</code>, som seg hør og
bør i et kommandolinjeverktøy.</p>
<p>The macro can be configured through <code>command(...)</code>-arguments.</p>
<p>To know what the user has sent to the program, we just need to do the following:</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();
<span class="hljs-keyword">let</span> <span class="hljs-variable">show_today</span> = cli.idag == <span class="hljs-literal">true</span> | | cli.idag == <span class="hljs-literal">false</span> &amp; &amp; cli.imorgen == <span class="hljs-literal">false</span>;
<span class="hljs-keyword">let</span> <span class="hljs-variable">show_tomorrow</span> = cli.imorgen == <span class="hljs-literal">true</span>;
</code></pre>
<p>This way, we can show either today's, tomorrow's or both prices at the same time.</p>
<h2>The price of power</h2>
<p>To use the Tibber API, you need to <a href="https://developer.tibber.com/docs/guides/calling-api">create an API token</a>.
Obviously, we can't hardcode a personal token into the source code. Also, we do not want it to end up in the
command line history. Therefore, we read it in as an environment variable.</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-variable">token</span> = <span class="hljs-keyword">match</span> env::<span class="hljs-title function_ invoke__">var_os</span>(<span class="hljs-string">"TIBBER_API_TOKEN"</span>) {
<span class="hljs-title function_ invoke__">Some</span>(v) =&gt; v.<span class="hljs-title function_ invoke__">into_string</span>().<span class="hljs-title function_ invoke__">unwrap</span>(),
<span class="hljs-literal">None</span> =&gt; panic ! (<span class="hljs-string">"$TIBBER_API_TOKEN is not set"</span>)
};
</code></pre>
<p><code>env::var_os</code> returnerer en <code>Option</code>, som er Rust sin idiomatiske måte å håndtere verdier som kan være tomme. Ikke
noe <a href="https://en.wikipedia.org/wiki/Null_pointer">billion dollar mistake</a> her i gården.</p>
<p>Rust har også pattern matching via <code>match</code>, som gir kompileringsfeil om du ikke håndterer alle mulige utfall. Definitivt
noe av det jeg liker aller best med Rust så langt.</p>
<p>Hvis programmet ikke finner miljøvariabelen, så er det bare å gi opp via <code>panic</code>.</p>
<p>Tibber sitt API er Graphql-basert. Det finnes Rust-bibliotek som kan autogenerere klientkode basert på Graphql-skjemaet
til
APIet, men for vårt formål er det overkill. Vi gjør heller bare en POST direkte ved
hjelp av <a href="https://docs.rs/reqwest/latest/reqwest/">reqwest</a>-craten.</p>
<p>Here's a helper function that executes a Graphql-query <code>q</code> and adds the personal token in the header of the request.</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(token: &amp;<span class="hljs-type">String</span>, q: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Response { 
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">body</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();
  body.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">"query"</span>, q);

  <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();
  <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = client
    .<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">"https://api.tibber.com/v1-beta/gql"</span>)
    .<span class="hljs-title function_ invoke__">json</span>(&amp;body)
    .<span class="hljs-title function_ invoke__">header</span>(AUTHORIZATION, <span class="hljs-string">"Bearer "</span>.<span class="hljs-title function_ invoke__">to_owned</span>() + &amp;token)
    .<span class="hljs-title function_ invoke__">header</span>(CONTENT_TYPE, <span class="hljs-string">"application/json"</span>)
    .<span class="hljs-title function_ invoke__">header</span>(ACCEPT, <span class="hljs-string">"application/json"</span>)
    .<span class="hljs-title function_ invoke__">send</span>()
    .<span class="hljs-keyword">await</span>
    .<span class="hljs-title function_ invoke__">unwrap</span>();
  response
}
</code></pre>
<p>For å hente f.eks nåværende pris, så ser det slik ut:</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = <span class="hljs-string">"{
  viewer {
    homes {
     currentSubscription {
       priceInfo {
         current {
           total
           energy
           tax
           startsAt
         }
       }
     }
   }
 }
}"</span>;

<span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-title function_ invoke__">query</span>( &amp; token, q).<span class="hljs-keyword">await</span>;
</code></pre>
<h2>Parsing JSON</h2>
<p>Å ta inn data fra den ville, skumle utsiden inn i et sterkt typet program er en interessant øvelse.
Typer hjelper deg å være internt konsistent i programmet ditt, men du kan i prinsippet få inn hva som helst
fra utsiden.</p>
<p>The first we do is to check if the status on the response is as expected:</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">match</span> response.<span class="hljs-title function_ invoke__">status</span>() {
  reqwest::StatusCode::OK =&gt; {
    <span class="hljs-comment">// Handle the proper flow</span>
  }
  other =&gt; {
    <span class="hljs-comment">// Handle all other statuses</span>
    <span class="hljs-comment">// The best we can do is to panic</span>
    panic ! (<span class="hljs-string">"Uh oh! Something unexpected happened: {:?}"</span>, other);
  }
};
</code></pre>
<p>Hvis statuskoden er OK, så kan vi parse JSON-bodyen. Det gjør vi ved å kalle <code>serde::from_str</code>. Typen som vi sender
inn blir brukt av parseren, dvs <code>ApiResponse&lt;PriceViewer&gt;</code>.</p>
<pre><code class="language-rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-variable">response_text</span> = response.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();

<span class="hljs-comment">// Vi sender typen til forventet respons som ApiResponse&lt;PriceViewer&gt;</span>
<span class="hljs-keyword">match</span> serde_json::from_str::&lt;ApiResponse&lt;PriceViewer&gt; &gt; ( &amp; response_text) {
  <span class="hljs-title function_ invoke__">Ok</span>(parsed) =&gt; <span class="hljs-title function_ invoke__">Some</span>(parsed),
  <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; {
    println ! (<span class="hljs-string">"FAILED TO PARSE! {:?} {:?}"</span>, e, response_text);
    <span class="hljs-literal">None</span> <span class="hljs-comment">// Det siste blir implisitt returnert</span>
  }
}
</code></pre>
<p>Forventet respons er definert som <code>structs</code>. Jeg fant ikke en måte å definere nøstede structs på annet enn
et <a href="https://github.com/rust-lang/rfcs/pull/2584">forkastet forslag</a>. Så jeg endte opp med å lage structs for hvert nivå
i responsen. Det blir altså litt boilerplate. Som jeg nevnte tidligere så kan det unngås ved å bruke et bibliotek som f.eks <a href="https://crates.io/crates/graphql_client">graphql_client</a></p>
<p>En <code>ApiResponse</code> har generisk <code>Data</code>, som har en generisk <code>viewer</code>. APIet har flere typer <code>viewers</code>. <code>PriceViewer</code> har
en liste med <code>Home</code>s.
Every <code>Home</code> has a <code>Subscription</code>, which has a <code>PriceInfo</code>, which have multiple <code>Price</code> for now , today and tomorrow.</p>
<pre><code class="language-rust hljs"><span class="hljs-meta">#[derive(Deserialize)]</span>
<span class="hljs-meta">#[serde(rename_all = <span class="hljs-string">"camelCase"</span>)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Price</span> {
  total: <span class="hljs-type">f64</span>,
  energy: <span class="hljs-type">f64</span>,
  starts_at: <span class="hljs-type">String</span>,
}
</code></pre>
<p><code>derive(Deserialize)</code> trigger <code>serde</code>-biblioteket sin <code>Deserialize</code> macro, som brukes når man parser JSON. Rust setter
strenge krav til navngiving, som gjør at vi må bruke <code>serde</code> sin <code>rename_all</code> macro for å håndtere at man ikke får
bruke camelCase på props i en <code>struct</code>.</p>
<h2>ASCII-graph</h2>
<p>We get visualization of the chart for free by the <code>rasciigraph</code>-crate.
It takes a lisst of values and make a string we can print.</p>
<pre><code class="language-rust hljs"><span class="hljs-built_in">println!</span>(
  <span class="hljs-string">"{}"</span>,
  <span class="hljs-title function_ invoke__">plot</span>(price_info.today.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|p| p.total).<span class="hljs-title function_ invoke__">collect</span>(),
       Config::<span class="hljs-title function_ invoke__">default</span>()
         .<span class="hljs-title function_ invoke__">with_width</span>(<span class="hljs-number">24</span> * <span class="hljs-number">4</span>)
         .<span class="hljs-title function_ invoke__">with_offset</span>(<span class="hljs-number">0</span>)
         .<span class="hljs-title function_ invoke__">with_height</span>(<span class="hljs-number">10</span>),
  )
);
</code></pre>
<p>Unfortunately <code>rasciigraph</code> does not support an x-axis, so here I have (temporarily) commited a great sin and hardcoded
a time axis from <code>00:00</code> to <code>24:00</code>.</p>
<p>That completes our program. It is now <a href="https://doc.rust-lang.org/cargo/reference/publishing.html">easy</a> to publish it to <a href="https://crates.io/crates/energipris">crates.io</a>, which makes it easy
for anyone to install it with the following command:</p>
<p><code>cargo install energipris</code></p>
<h2>Advantages with Rust</h2>
<ul>
<li>Rust is a language <a href="https://survey.stackoverflow.co/2022#technology-most-loved-dreaded-and-wanted">many love</a>.</li>
<li>Det har solid støtte for å lage verktøy til kommandolinjen</li>
<li>Det er raskt
<ul>
<li>Det er sjelden at ytelse er et avgjørende argument i disse dager med lynrask hardware, ofte er det viktigere at
programmet er lett å forstå og vedlikeholde</li>
</ul>
</li>
<li>Sterke garantier fra kompilatoren
<ul>
<li>"Når det kompilerer så virker det" er noe jeg ofte hører fra de som liker sterke typesystemer.</li>
<li>Det krever riktignok at man bruker tid på å finne de riktige typene, noe som kan være vanskelig tidlig i et
prosjekt før man har skjønt domenet skikkelig</li>
</ul>
</li>
<li>God støtte for concurrency</li>
</ul>
<h2>Disadvantages with Rust</h2>
<ul>
<li>Det er ikke til å skyve under en stol at det tar tid å lære seg Rust
<ul>
<li>Dette er ikke bare en bedre C eller Java, dette er noe ganske annet</li>
<li>Er det verdt å lære seg? Definitivt, det vil utvide horisonten din</li>
</ul>
</li>
<li>Treg kompilering
<ul>
<li>Det tar overraskende lang tid å kompilere selv små prosjekt</li>
</ul>
</li>
<li>Strict compiler
<ul>
<li>Hvis målet er å kjapt teste ut et API eller en idé, så finnes det andre språk som gir deg en raskere
utviklingshastighet.</li>
</ul>
</li>
<li>Macros can be abused
<ul>
<li>Jeg vil heller ha mer boilerplate som jeg kan lese og forstå enn magiske makroer som "bare" er en annotasjon. Jeg
har blitt brent for mange ganger av "smart" eller "imponerende" kode som liksom skal spare meg for masse arbeid.</li>
</ul>
</li>
</ul>
<h2>Summary</h2>
<p>Rust er såpass annerledes fra de andre språkene jeg kan at det var vanskelig å bare begynne i en ende og kode seg
til noe som funker. Jeg traff raskt en vegg med feilmeldinger fra kompilatoren som jeg ikke hadde forutsetning for å
forstå. Det gjelder altså å karre til seg nok basiskunnskap først, selv om feilmeldingene var aldri så hjelpsomme.</p>
<p>I'd recommend reading through the <a href="https://doc.rust-lang.org/book/">Rust-book</a> to get going.</p>
<p>Would I recommend using Rust to make a command line tool?
Uten tvil, spesielt hvis det er viktig at programmet er
stabilt eller CPU-intensivt. Hvis du imidlertidig bare trenger å raske sammen et verktøy for en mindre greie, så ville
jeg heller foreslått f.eks Python, bash eller Node/Deno.</p>
<p>The extra curious can read <a href="https://github.com/Odinodin/energipris">the source</a></p>

    </div>
  </main>
  <footer>
        <a href="https://github.com/odinodin">Github</a>
        <a href="https://www.kodemaker.no">Kodemaker</a>
        <a href="https://bsky.app/profile/odinodin.bsky.social">BlueSky</a>
        <a href="https://www.linkedin.com/in/odinholestandal/">Linkedin</a>
</footer>
  <div>

</div></div></body></html>